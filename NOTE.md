# java 并发核心知识体系精讲
核心基础 + 内存模型 + 死锁 ----- 从用法到原理
## 章节一、线程8大核心基础知识

### 一、实现多线程的方法到底有1种还是2中还是4种？(实现多线程的短信错误和正确方法)
#### 1、正确的理解 (2种)
##### 方法一、实现Runnable接口，重写run()函数；运行start()方法
    更好
##### 方法二、继承Thread类，重写run()函数，运行start()方法
    缺点：
        从架构的角度来讲，任务的执行(run方法)和线程的创建应该是解耦的，不应该混为一谈
        如果继承了Thread类，就需要新建一个线程来启动这个线程，执行完之后还需要释放资源，而实现了Runnable接口可以利用线程池来优化
        java是单继承的，限制了可扩展性 
##### 思考：同时用2中方法会怎么样？
###### 用面向对象的思想去考虑 
    实现Runnable接口以后，执行执行重写的run()方法之前会执行
        @Override
            public void run() {
                if (target != null) {
                    target.run();
                }
            }
    而继承了Thread类以后，重写了run()方法则会覆盖父类的这行代码
    所以同时使用Runnable和Thread的时候，target也是会通过构造器传入进去的，但是被覆盖以后就不会被执行了  
##### 俩种方法对比
###### 方法一: 最终调用target.run()
###### 方法二: run() 整个都被重写
##### 总结：最精准的描述
###### 1、通常我可可以分为两类，Oracle也是这么说的
###### 2、准确的将，创建线程只有一种方式那就是构造Thread类，而实现线程的执行单元有两种方式
    方法一：实现Runnable接口的run方法，并把Runnable实例传给Thread类
    方法二：重写Thread的run方法(继承Thread类)
#### 2、经典错误观点
##### "线程池创建线程也算一种新建线程的方式"
    不对，线程池底层创建线程的本质也是new Thread()
##### "通过Callable和Future创建线程，也算是一种新建线程的方式"
    不对， 底层也是依赖 实现了Runnable接口
##### "无返回值是实现Runnable接口，有返回值是实现Callable接口，所以Callable是新的实现线程的方式"
##### 定时器
    不对，底层还是线程类的包装
##### 匿名内部类

##### lambda表达式
##### 典型错误观点总结
###### 1、多线程的实现方式，在代码中写法千变万化，但其本质万变不离其宗
#### 3、常见面试问题
##### 有多少种实现线程的方法？思路有5点
###### 1、从不同的角度看，会有不同的答案。
###### 2、典型答案是两种
###### 3、我们看原理，两中本质都是一样的
###### 4、具体展开说其他方式
    线程池、计时器、匿名内部类等等
###### 5、结论
    本质上只有一种，它是新建Thread类，但是通常我们把它区分为俩种形式，
    一种是Runnable、一种是继承Thread类，还存在其他的表现形式：线程池、计时器、lambda、匿名内部类
##### 实现Runnable接口和继承Thread类那种方式更好？
###### 1、从代码架构角度：任务的执行(run方法)和线程的创建应该是解耦的，不应该混为一谈
###### 2、新建线程的损耗：如果继承了Thread类，就需要新建一个线程来启动这个线程，执行完之后还需要释放资源，而实现了Runnable接口可以利用线程池来优化，从而进行反复的利用
###### 3、Java不支持双继承

#### 4、彩蛋：
##### 如何从宏观和微观俩个方面来提高技术？
##### 如何了解技术领域的前沿动态？
##### 如何在业务开发中成长？

### 二、启动线程的正确和错误的方法
#### 1、start()和run()的比较
#### 2、start()方法原理解读
##### 方法含义
###### 1、启动新线程
    通知jvm有时间运行一下这个线程
###### 2、准备工作
    线程处于就绪状态
###### 3、不能重复start
##### 源码解读
###### 1、启动新线程检查线程状态
###### 2、加入线程组
###### 3、调用start0()
###### native start()方法

#### 3、run()方法原理解读
##### 源码解析 --- 俩种情况
#### 4、常见面试问题
##### 一个线程俩次调用start()方法会出现什么情况？为什么？
###### 会抛出异常，因为在start()源码中首先会进行线程状态的检查  
##### 既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？
###### 因为调用start()方法才是真正意义上启动一个线程，如果直接调用一个run()方法就是调用一个普通的方法


### 三、停止线程的正确方法(重要、难点) -- 上山容易下山难
#### 1、原理介绍：使用interrupt来通知，而不是强制
#### 2、最佳实践：如何正确停止线程
##### 通常的停止过程 (无外界干涉的情况下)
###### 线程执行完以后就会停止
###### 线程执行的过程中抛出了异常
##### 正确方法：用interrupt来请求停止线程
###### 普通情况(run方法内没有sleep或wait方法时的写法)
###### 线程可能被阻塞 包含sleep()方法
###### 如果线程在每次工作迭代之后都阻塞(调用sleep方法等)
###### while内try/catch的问题  会导致线程无法停止
#### 实际开发中的最佳实践
##### 1、优先选择：传递中断
##### 2、不想或无法传递：恢复中断
##### 3、不应屏蔽中断
#### 响应中断的方法总结列表
###### 可以为了响应中断而抛出InterruptException的常见方法列表总结
    响应中断指的是在wait、sleep、join...等过程中，如果有一个中断信号过来了，它能够感知到，及时响应中断
##### 1、Object.wait()/wait( long)/wait(long, int)
##### 2、Thread.sleep(long)/sleep(long, int)
##### 3、Thread.join()/join(long)/join(long, int)
##### 4、java.util.concurrent.BlockingQueue.task()/put(E)
##### 5、java.util.concurrent.locks.Lock.lockInterruptibly()
##### 6、java.util.concurrent.CountDownLatch.await()
##### 7、java.util.concurrent.CyclicBarrier.await()
##### 8、java.util.concurrent.Exchanger.exchanger(V)
##### 9、nio.channels.InterruptibleChannel相关方法
##### 10、java.nio.channels.Selector的相关方法  

##### 为什么要我们要使用interrupt来停止线程？好处
    被中断的线程本有拥有如何响应中断的权利，
    因为某些线程的某些代码是非常重要的，我们必须等待这些线程准备好之后主动释放

#### 3、错误的停止方法
##### 被弃用的stop、suspend和resume方法
###### 使用stop的后果
###### 关于stop的一种错误理论
###### suspend的问题
    suspend 并不会破坏对象，但是它会让一个线程挂起，在恢复之前，锁不会释放，也就是它是带着锁去休息的，这就很容易会造成死锁
##### 用volatile设置boolean标记位
###### 这种停止方法也是不对的， 无法停止处于长时间阻塞等待的线程
#### 4、停止线程相关的重要函数解析
##### 中断线程
###### interrupt方法原理
##### 判断是否已被中断
###### static boolean interrupted()
    检测当前线程(执行该方法的线程)的状态是否是中断状态， 在结果返回之后，
    直接把当前线程的中断状态设为false，直接把线程中断状态给清除了，
    这也是我们唯一能清除线程中断状态的方法
###### boolean isInterrupted()
    同样是检测当前线程的状态是否是中断状态，不会清除线程的中断状态
###### 举例说明，注意Thread.interrupted的目标是"当前线程",而不管方法是来自哪
#### 5、常见面试问题
##### 如何停止线程？
    1、原理： 用interrupt来请求，好处可以保证数据安全，要把线程中断的主动权交给被中断的线程
    2、想停止线程，要请求方（提交中断请求 -- interrupt）、
        被停止方（要设置拦截请求中断 比如 isInterrupted 或者 包含响应中断的方法 sleep、 wait、join ...）、
        子方法被调用方（在编写子方法的时候要将异常显示的抛出，而不要将异常隐藏， 这里的异常通常是 InterruptedException）相互配合
    3、最后再说错误的方法： stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况
##### 如何处理不可中断的阻塞(例如抢锁时ReentrantLock.lock()或者Socket I/O时无响应中断，那应该怎么让该线程停止呢？)
###### 并没有通用的处理手段 
    ReentrantLock可重入锁，如果真的使用了lock()方法，并且在执行过程中被阻塞了，是没有办法相应中断线程的。
        但是这个类提供了lockInterruptibly()方法，这个方法是可以相应中断的
    针对传统的IO阻塞，是没有办法相应中断的，但是可以使用特定的IO操作。

### 四、线程的6个状态(线程的生命周期)
#### 有哪6个状态？ 每个状态是什么含义
    New(新建)                 用new Thread()新建了一个线程，还没有执行thread.start()
    Runnable(可运行)          用了thread.start()方法以后, 针对了操作系统中的ready和running俩种状态
    Blocked(阻塞)             当一个线程进入到被synchronize修饰的时候，并且该锁已经被其他线程拿走了，也就是该monitor已经被其他线程拿走了            
    Waiting(等待)             当调用Object.wait()、Thread.join()、LockSupport.park()      
    Timed Waiting(定时等待)   当调用Thread.sleep(time)、Object.wait(time)、Thread.join(time)、LockSupport.parkNanos(time)、LockSupport.parkUntil(time)
    Terminated(终止)          执行完成
##### Blocked状态和Waiting状态的区别是：Blocked状态等待的是其他线程释放一个排他锁，释放一个monitor；而Waiting和Timed Waiting等待的被唤醒或者一段被设置好的时间

#### New已创建但还尚未启动的新线程
#### Runnable可运行
#### Blocked被阻塞
#### waiting等待
#### Timed waiting 限期等待
#### Terminated终止
#### 阻塞状态
#### 线程状态的源码分析
#### 常见面试问题
##### 线程有哪几种状态？ 声明周期是什么
### 五、Thread和Object类中和线程相关的重要方法
#### 常用方法概览
#### wait()、notify()、notifyAll()方法
##### wait/notify/notifyAll的作用、用法
###### 阻塞阶段
###### 唤醒阶段
###### 遇到中断
##### 代码展示
###### 普通用法
###### notify和notifyAll展示
###### 只释放当前monitor展示
##### wait/notify/notifyAll的特点、性质
##### 原理
##### 注意点
###### 执行wait/notify/notifyAll前必须获得对应的monitor
###### 过多的上下文切换，造成性能损耗
###### 唤醒信号丢失
###### 过早唤醒问题 (Wakeup too soon)
##### 常见面试问题
###### 用程序实现俩个线程交替打印 0 - 100 的奇偶数 
###### 手写生产者消费者设计模式
###### 为什么wait()需要在同步代码块内使用，而sleep不需要
###### 为什么线程通信的方法wait()、notify()和notifyAll()被定义在Object类里？而sleep定义在Thread类里？
###### wait()方法是属于Object对象的，那调用Thread.wait()会怎么样？
###### 如何选择用notify还是notifyAll
###### notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？
###### 用suspend()和resume()来阻塞线程可以吗？为什么？
#### sleep()方法详解
##### 作用
##### 响应中断
###### 代码例子
###### 第二种语法(更优雅)
##### 原理
##### 总结(一句话总结，方便记忆)
#### join()方法
##### 作用
##### 语法
##### 例子 
###### 普通用法
###### 遇到中断
###### 在join期间，线程到底是什么状态?
##### 注意点
##### join(原理) 
###### 分析源码
##### 常见面试问题 
###### 在join期间，线程处于那种线程状态
#### yield()方法
##### 作用
##### 定位
##### yeild 和 sleep 区别
#### 获取当前执行线程的引用: Thread.currentThread()方法
#### start()和run()方法介绍详见《启动线程的正确方式》
#### stop()、suspend()、resume()详见《错误的停止方法》
### 六、线程各属性
#### 线程各属性纵览
#### 线程id
#### 线程名字 
##### 默认名称源码分析
##### 修改线程的名字
#### 守护线程
##### 作用： 给用户线程提供服务
##### 特性：
###### 线程类型默认继承自父线程
###### 被谁启动？
##### 守护线程和普通线程的区别
##### 常见面试问题
###### 守护线程和普通线程的区别
###### 我们是否需要给线程设置为守护线程？
#### 线程优先级
##### 10 个级别
##### 程序设计不应该依赖于优先级
#### 各属性的赋值阶段 --- 线程的初始化过程
#### 各属性总结
#### 面试常见问题 
##### 为什么Java中不建议使用线程组
### 七、线程的为捕获异常UncaughtException应该如何处理？
#### 为什么需要UncaughtExceptionHandler？
#### 彩蛋：补充知识点 --- Java异常体系
#### 解决方案
#### 面试常见问题
##### 方案一(不推荐): 手动在每个run方法里进行try catch
##### 方案二(推荐) : 利用UncaughtExceptionHandler
###### 默认的UncaughtExceptionHandler
###### 异常处理器的调用策略
###### 自己继承并实现UncaughtException
##### 常见面试问题
###### run方法是否可以跑出异常？ 如果跑出异常，线程的状态回事怎么样？
###### 线程中如何处理某个未处理异常
### 八、线程是把双刃剑：多线程或导致性能问题(线程引入的开销，上下文切换)
#### 线程安全
##### 什么是线程安全
##### 什么情况下会出现线程安全问题，怎么避免
###### 运行结果错误(a ++ 多线程下出现消失的请求现象，属于read-modify-write)
###### 死锁等活跃性问题(包括死锁、活锁、饥饿)
###### 对象发布和初始化的时候的安全问题
###### 总结归纳：各种需要考虑线程安全的情况
#### 性能问题有哪些体现，什么是性能问题
#### 为什么多线程会带来性能问题
##### 调度：上下文切换
##### 协作：内存同步
#### 常见面试问题

### 常见面试题