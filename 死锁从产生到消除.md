# 死锁 -- 从产生到消除

## 考考你
### 1、写一个必然死锁的例子

### 2、发生死锁必然满足哪些条件？

### 3、如何定位死锁？

### 4、有哪些解决死锁问题的策略？

### 5、讲讲经典的哲学家就餐问题

### 6、实际工程中如何避免死锁？

### 7、什么是活跃性问题？ 活锁、饥饿和死锁有什么区别？


## 一、死锁是什么？有什么危害？

### 1、什么是死锁？

#### 1>、发生在并发中

#### 2>、互不相让： 当两个(或更多)线程(或进程)相互持有对方所需要的资源，又不主动释放，导致所有人都无法继续前进，导致程序陷入无尽的阻塞，这就是死锁

#### 3>、一图胜千言

![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/sisuoanlitupian1.png)

![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/sisuoanlitupian2.png)

### 2、多个线程造成死锁的情况

#### 3>、如果多个线程之间的依赖关系是环形，存在环路的锁的依赖关系，那么也可能会发生死锁

![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/duogexianchengsisuoanli1.png)

### 3、死锁的影响

* 死锁的影响在不同系统值是不一样的，这取决于系统对死锁的处理能力

#### 1>、数据库中：检测并放弃事务
    (如果发生了死锁，系统会检测并放弃某一个事务来中断死锁，等其他事务执行完之后，再执行这个事务)
    与具体的系统和数据库引擎有关系

#### 2>、JVM中：无法自动处理(具有检测的能力，但是不能自动处理)
    JVM不能分清线程的先后重要性，所以不能先斩后奏的进行处理，必须要求开发人员自己注意

### 4、几率不高但危害大

#### 1>、不一定发生，但是遵守"墨菲定律"

#### 2>、一旦发生，多是高并发场景，影响用户多

#### 3>、真个系统崩溃，子系统崩溃，性能降低

#### 4>、压力测试无法找出所有潜在的死锁

## 二、发生死锁的例子

### 1、最简单的情况

#### 1>、代码

#### 2>、注意看退出信号：Process finished with exit code 130 (interrupted by signal 2: SIGINT)，是不正常退出的信号，对比正常结束的程序的结束信号是0


### 2、实际生产中的例子：转账

#### 1>、单机情况下

* 需要两把锁

* 获取两把锁成功，且余额大于0，则扣除转出人，增加收款人的余额，是原子操作

* 顺序相反导致死锁

#### 2>、单机和分布式架构演进


### 3、模拟多人随机转账

#### 1>、5万人很多，但是依然会发生死锁，墨菲定律

#### 2>、复习：发生死锁记几率不高但危害大


### 3、死锁的4个必要条件

* 1、互斥条件
    
    
    一个资源每一次只能被同一个进程或者线程使用
    
* 2、请求与保持条件


    第一个线程去请求第二把锁，但是同时又保持第一把锁，而这个请求的时候，自身处于阻塞状态，已经获取的资源被保持并处于不释放状态
    
* 不剥夺条件


    不能有外界来干扰剥夺处于阻塞的线程已经获取的资源
    
* 循环等待条件


    阻塞线程之间需要构成环路，也就是一个接一个的需要下一个已经占有的资源，并且形成环路
    
#### 缺一不可，逐个分析之前的例子

### 4、如何定位死锁？

* jstack 


    java中的一个命令
    
* ThreadMXBean代码演示
    

### 5、修复死锁的策略

#### 1>、线上发生死锁应该怎么办？

* 线程问题都需要防患于未然，不造成损失地扑灭几乎已经是不可能

* 保存案发线程然后立即重启服务器

* 暂时保存线上服务的安全，然后在利用刚才保存的信息，排查死锁，修改代码，重新发版

#### 2>、常见修复策略

##### （1）、避免策略：哲学家就餐的换手方案，转账换序方案

* 1、思路：避免相反的获取锁的顺序   
* 2、转账是避免死锁
    通过判断俩个或者多个锁对象的hash值大小，来规定加锁的先后顺序， 这样就能有效额避免死锁
    
    
    1、实际上不在乎获取锁的顺序
    2、代码演示
    3、通过hashcode来决定获取锁的顺序，冲突是需要 "加时赛"
    4、有主键就更方便
    
* 3、哲学家就餐问题
    
###### 问题描述：
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/zhexuejiajiucanwenti.jpg) 
    
    1、先拿起左右的筷子
    2、然后拿起右手的筷子
    3、如果筷子被别人使用了，那就等别人用完
    4、吃完了把筷子放回去
    
    伪代码：
    
    while(true){
        // Initially,thinking about life, universe, and everything 
        think();
        // Take a break from thinking, hungry now
        pick_up_left_fork();
        pock_up_right_fork();
        eat();
        put_down_right_fork();
        put_down_left_fork();
        // Not hungry anymore, Back to thinking!
    }
    
###### 有死锁和资源耗尽的风险
    1、死锁：每个哲学家都拿着左手的筷子，永远都在等右边的筷子(或者相反)

###### 代码演示： 哲学家进入死锁

###### 多种解决方案
    1、服务员检查(避免策略)
    2、改变一个哲学家拿叉子的顺序(避免死锁)
    3、餐票(避免策略)
    4、领导调节(检测与恢复策略)

###### 代码演示：解决死锁


##### （2）、 检测与恢复策略： 一段时间检测是否有死锁，如果有就剥夺某一个资源，来打开死锁

###### 允许发生死锁
###### 每次调用锁都记录    (用图数据结构来记录，  有向图)
###### 定期检查 "所得调用链路图" 中是否存在环路
###### 一旦发生死锁， 就用死锁恢复机制进行恢复

* 死锁检测与恢复策略
###### 检测算法：锁的调用链路图
###### 恢复方法1：进程终止
    1、逐个终止线程，知道自锁消除。
    2、终止顺序：
        ①、优先级(是 前台交互 还是 后台处理 )
        ②、已占用资源、还需要的资源
        ③、已经运行时间
        
###### 资源抢占        
    1、把已经分出去的锁收回来
    2、让线程回退几步，这样就不用结束真个线程，成本比较低
    3、缺点：可能同一个线程一直被抢占，那就造成线程饥饿


##### （3）、 鸵鸟策略： 鸵鸟这种动物在遇到危险的时候，通常就会把头埋在地下，这样一来它就看不到危险了。而鸵鸟策略的意思就是说，如果我们发生死锁的概率极其低，那么我们就直接忽略它，直到死锁发生的时候，再人工修复


### 6、实际工程中如何有效的避免死锁

#### 1>、设置超时时间

##### （1）、Lock的tryLock(long timeout, TimeUnit unit)

##### （2）、synchronized不具备尝试锁的能力

##### （3）、造成超时的可能性多： 发生了死锁、线程陷入死循环、线程执行很慢

##### （4）、获取锁失败： 打日志、 发报警邮件、重启等

##### （5）、代码演示

#### 2>、多使用并发类而不是自己设计锁

##### （1）、ConcurrentHashMap、ConcurrentLinkedQueue、AtomicBoolean等

##### （2）、实际应用中java.util.concurrent.atomic十分有用，简单方便且效率比使用Lock更高

##### （3）、多用并发集合少用同步稽核，并发集合比同步集合的可扩展性更好

##### （4）、并发场景需要用到map，首先想到用ConcurrentHashMap


#### 3>、尽量降低锁的使用粒度： 用不同的锁而不是一个锁

    锁所保护的范围，只要是能满足要求，那么是越小越好

#### 4>、如果能使用同步代码块，就不适用同步方法： 自己制定锁对象

#### 5>、给你的线程起个有意义的名字： debug和排查时事半功倍，框架和JDK都遵守这个最佳实践

#### 6>、避免锁的嵌套： 详情请看MustDealLock类

#### 7>、分配资源前先看看能不能收回来：银行家算法

#### 8>、尽量不要几个功能用同一把锁： 专锁专用


## 二、其他活性故障

### 1、死锁是最常见的活跃性问题，不过除了刚才的死锁之外，还有一些类似的问题，会导致程序无法顺利执行，统称为活跃性问题

### 2、活锁

#### 1>、什么是活锁

##### （1）、线程没有阻塞而是始终在运行

##### （2）、线程虽然在运行，但是始终得不到进展

#### 2>、代码演示

#### 3>、工程中的活锁实例：消息队列

##### （1）、策略： 消息如果处理失败， 就放在队列开头重试

##### （2）、由于依赖服务出了问题，处理该消息一直失败

##### （3）、没阻塞，但程序无法继续

##### （4）、解决：放到对垒尾部、重试限制(设置重试上限)

#### 4>、如何解决活锁问题

##### （1）、原因：重试机制不变，消息队列始终重试，吃放始终谦让

##### （2）、以太网的指数退避算法
    重试时间是随机的，并且每次碰撞之后会增加重试时间
    
##### （3）、加入随机因素

### 3、饥饿

#### 1>、当线程需要某些资源(例如CPU)，但是却始终得不到

#### 2>、线程的优先级设置得过于低，或者有某线程持有锁同时又无限循环从而不释放锁，或者某程序始终占用某文件的写锁

#### 3>、饥饿可能会导致响应性差：比如，我们的浏览器有一个线程负责处理前台响应(打开收藏夹等动作)，另外的后台线程负责下载图片和文件、计算渲染等。这种情况下，如果后台线程吧CPU资源都占用了，那么前台线程将无法得到很好地执行，这会导致用户的体验很差


## 三、常见的面试问题

### 1、写一个必然死锁的例子，生产中什么场景下会发生死锁？

* 在一个方法中获取多个锁，这样容易发生死锁
* 在一个方法中获取一个锁，然后去调用其他方法，而其他方法也获取锁了，这就相当于循环调用，也可能会造成死锁

### 2、想要发生死锁都需要满足那些条件呢？
* 互斥条件
* 请求与保持条件
* 不剥夺条件
* 循环等待条件

### 3、如何定位死锁

* jstack工具： 发生死锁之后，对堆栈进行分析
* ThreadMXBean类：    防患于未然，程序运行中就可以通过这个类来发现死锁，比如通过定时任务来定时扫描，如果发现死锁，就重启线程或者发送报警或者记录日志，保证死锁问题及时解决

### 4、有哪些解决死锁问题的策略？

* 避免策略：哲学家就餐的换手方案， 转账换序方案
* 检查与恢复策略：一段时间检测是否有死锁，如果有就剥夺某一个资源，来打开死锁
* 鸵鸟策略

### 5、讲一讲经典的哲学家就餐问题

* 改一个哲学家拿筷子的顺序(避免策略)

### 6、实际工程汇总如何避免死锁的发生呢？

* 1、设置超时时间
* 2、多使用并发类而不是自己设计锁
* 3、尽量降低锁的使用粒度：用不同的锁而不是一个锁
* 4、如果能使用同步代码块，就不适用同步方法：自己指定锁的粒度
* 5、给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都是这样做的
* 6、避免锁的嵌套：详情看MustDeadLock类
* 7、分配资源前先看能不能收回来：银行家算法
* 8、尽量不要几个功能用同一把锁：专锁专用

### 7、什么是活跃性问题？活锁、饥饿和死锁有什么区别？

