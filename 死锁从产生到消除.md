# 死锁 -- 从产生到消除

## 考考你
### 1、写一个必然死锁的例子

### 2、发生死锁必然满足哪些条件？

### 3、如何定位死锁？

### 4、有哪些解决死锁问题的策略？

### 5、讲讲经典的哲学家就餐问题

### 6、实际工程中如何避免死锁？

### 7、什么是活跃性问题？ 活锁、饥饿和死锁有什么区别？


## 一、死锁是什么？有什么危害？

### 1、什么是死锁？

#### 1>、发生在并发中

#### 2>、互不相让： 当两个(或更多)线程(或进程)相互持有对方所需要的资源，又不主动释放，导致所有人都无法继续前进，导致程序陷入无尽的阻塞，这就是死锁

#### 3>、一图胜千言

![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/sisuoanlitupian1.png)

![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/sisuoanlitupian2.png)

### 2、多个线程造成死锁的情况

#### 3>、如果多个线程之间的依赖关系是环形，存在环路的锁的依赖关系，那么也可能会发生死锁

![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/duogexianchengsisuoanli1.png)

### 3、死锁的影响

* 死锁的影响在不同系统值是不一样的，这取决于系统对死锁的处理能力

#### 1>、数据库中：检测并放弃事务
    (如果发生了死锁，系统会检测并放弃某一个事务来中断死锁，等其他事务执行完之后，再执行这个事务)
    与具体的系统和数据库引擎有关系

#### 2>、JVM中：无法自动处理(具有检测的能力，但是不能自动处理)
    JVM不能分清线程的先后重要性，所以不能先斩后奏的进行处理，必须要求开发人员自己注意

### 4、几率不高但危害大

#### 1>、不一定发生，但是遵守"墨菲定律"

#### 2>、一旦发生，多是高并发场景，影响用户多

#### 3>、真个系统崩溃，子系统崩溃，性能降低

#### 4>、压力测试无法找出所有潜在的死锁

## 二、发生死锁的例子

### 1、最简单的情况

#### 1>、代码

#### 2>、注意看退出信号：Process finished with exit code 130 (interrupted by signal 2: SIGINT)，是不正常退出的信号，对比正常结束的程序的结束信号是0


### 2、实际生产中的例子：转账

### 3、模拟多人随机转账



