# java 并发核心知识体系精讲
核心基础 + 内存模型 + 死锁 ----- 从用法到原理
## 章节二、Java内存模型 —— 底层原理

### 1、到底什么叫"底层原理"，本章研究的内容是什么？ （绪论）
#### 1>、从Java代码到CPU指令
##### JVM实现会带来不同的"翻译"，不同的CPU平台的机器指令又不相同
##### （1）、最开始，我们编写的Java代码，是 *.java文件
##### （2）、在编译（javac命令）后，从刚才的 *.java文件会变出一个新的 *.class文件
##### （3）、JVM会执行刚才生成的字节码文件（*.class），并把字节码文件转化为机器指令
##### （4）、机器指令可以直接在CPU上执行，也就是最终的程序执行

#### 2>、重点向下研究
##### 转换过程的规范、原则

### 2、彩蛋：自顶向下的好处
#### 1>、先讲使用场景，再将用法，最后讲原理
#### 2>、直观的了解、具体而感性的认识，有助于加深理解，最后分析源码
#### 3>、连这个原理有什么作用都不知道的话，我们可定是没有兴趣的，没兴趣就意味着学不好
#### 4>、例子：《计算机网络(自顶向下方法)》、C语言学int

### 3、三兄弟： JVM内存结构 VS Java内存模型 VS Java对象模型
#### 1>、容易混淆
##### （1）、三个截然不同的概念，但是很容易弄混

#### 2>、整体方向
##### （1）、Java内存结构，和Java虚拟机的运行时区域有关。
##### （2）、Java内存模型，和Java的并发编程有关。
##### （3）、Java对象模型，和Java对象在虚拟机中的表现形式有关。

#### 3>、JVM内存结构
##### （1）、图形展示
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/JVMneicunjiegou.jpg)
##### （2）、堆区（所有线程共享）
##### （3）、java栈 虚拟机栈 VM stack（每个线程私有）
##### （4）、方法区（所有线程共享）
    已经加载的静态变量，类信息或者常量信息，还包含着永久引用   
        比如 static People people = new People(); 就是永久引用
##### （5）、本地方法区（每个线程私有）
    主要保存和本地方法相关的， native方法
##### （6）、程序计数器（每个线程私有）
    保存当前线程所执行到的字节码的行号数，也就是在进行上下文切换的时候，这些数据需要保存起来
    还包括下一条需要执行的指令、分支、循环、和异常处理，这些都依赖程序计数器的

#### 4>、Java对象模型
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/Javaduixiangmoxing.jpg)
##### （1）、Java对象自身的存储模型
##### （2）、JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。
##### （3）、当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。
    会在栈中给对象赋值，会在堆中新建实例对象


### 4、JMM是什么？（Java Memory Model） Java内存模型
#### 1>、为什么需要JMM
##### （1）、C语言不存在内存模型的概念
##### （2）、由于不存在 内存模型 的概念，所以依赖处理器，不同的处理器结构不一样
##### （3）、无法保证并发安全， 很多情况下CPU会进行乱序
##### （4）、需要一个标准，让个县城运行的结果可预期


#### 2>、是规范
##### （1）、是一种规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序
#### 3>、是工具类和关键字的原理
#### 4>、最重要的3点内容

### 5、重排序 (JMM)

### 6、可见性 (JMM)

### 7、原子性 (JMM)

### 8、常见面试问题