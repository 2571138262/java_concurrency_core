# java 并发核心知识体系精讲
核心基础 + 内存模型 + 死锁 ----- 从用法到原理
## 章节二、Java内存模型 —— 底层原理

### 1、到底什么叫"底层原理"，本章研究的内容是什么？ （绪论）
#### 1>、从Java代码到CPU指令
##### JVM实现会带来不同的"翻译"，不同的CPU平台的机器指令又不相同
##### （1）、最开始，我们编写的Java代码，是 *.java文件
##### （2）、在编译（javac命令）后，从刚才的 *.java文件会变出一个新的 *.class文件
##### （3）、JVM会执行刚才生成的字节码文件（*.class），并把字节码文件转化为机器指令
##### （4）、机器指令可以直接在CPU上执行，也就是最终的程序执行

#### 2>、重点向下研究
##### 转换过程的规范、原则

### 2、彩蛋：自顶向下的好处
#### 1>、先讲使用场景，再将用法，最后讲原理
#### 2>、直观的了解、具体而感性的认识，有助于加深理解，最后分析源码
#### 3>、连这个原理有什么作用都不知道的话，我们可定是没有兴趣的，没兴趣就意味着学不好
#### 4>、例子：《计算机网络(自顶向下方法)》、C语言学int

### 3、三兄弟： JVM内存结构 VS Java内存模型 VS Java对象模型
#### 1>、容易混淆
##### （1）、三个截然不同的概念，但是很容易弄混

#### 2>、整体方向
##### （1）、Java内存结构，和Java虚拟机的运行时区域有关。
##### （2）、Java内存模型，和Java的并发编程有关。
##### （3）、Java对象模型，和Java对象在虚拟机中的表现形式有关。

#### 3>、JVM内存结构
##### （1）、图形展示
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/JVMneicunjiegou.jpg)
##### （2）、堆区（所有线程共享）
##### （3）、java栈 虚拟机栈 VM stack（每个线程私有）
##### （4）、方法区（所有线程共享）
    已经加载的静态变量，类信息或者常量信息，还包含着永久引用   
        比如 static People people = new People(); 就是永久引用
##### （5）、本地方法区（每个线程私有）
    主要保存和本地方法相关的， native方法
##### （6）、程序计数器（每个线程私有）
    保存当前线程所执行到的字节码的行号数，也就是在进行上下文切换的时候，这些数据需要保存起来
    还包括下一条需要执行的指令、分支、循环、和异常处理，这些都依赖程序计数器的

#### 4>、Java对象模型
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/Javaduixiangmoxing.jpg)
##### （1）、Java对象自身的存储模型
##### （2）、JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。
##### （3）、当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。
    会在栈中给对象赋值，会在堆中新建实例对象


### 4、JMM是什么？（Java Memory Model） Java内存模型
#### 1>、为什么需要JMM
##### （1）、C语言不存在内存模型的概念
##### （2）、由于不存在 内存模型 的概念，所以依赖处理器，不同的处理器结构不一样
##### （3）、无法保证并发安全， 很多情况下CPU会进行乱序
##### （4）、需要一个标准，让个县城运行的结果可预期


#### 2>、是规范
##### （1）、是一种规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序
##### （2）、如果没有这样的一个JMM内存模型来规范，那么很可能经过了不同JVM的不同规则的重排序之后，导致不同的虚拟机上运行的结构不一样了，这是很大的问题

#### 3>、是工具类和关键字的原理
##### （1）、volatile、synchronized、Lock等的原理都是JMM
##### （2）、如果没有JMM，那就需要我们自己指定什么时候用内存栅栏等，那是相当麻烦的，幸好有了JMM，让我们只需要用同步工具和关键字就可以开发程序。
    工作栅栏： 简单的理解就是工作内存和主内存的拷贝和同步

#### 4>、最重要的3点内容：重排序、可见性、原子性
    JMM 最重要的三点内容：重排序、可见性、原子性

### 5、重排序 (JMM)
#### 1>、重排序的代码案例、什么是重排序
##### （1）、什么是重排序：在线程1内部的两行代码的实际执行顺序和代码在Java文件中的顺序不一致，代码指令并不是严格按照代码语句顺序执行的，他们的顺序被改变了，这还是就重排序，这里被颠倒的是y=a和b=1这两行语句

#### 2>、重排序的好处：提高处理速度
##### （1）、对比重排序前后的指令优化
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/chongpaixudehaochu.jpg)

#### 3>、重排序的3中情况：编译器优化、CPU指令重排、内存的"重排序"
##### （1）、编译器优化：包括JVM， JIT编译器等
    假设编译器发现把俩个a的操作放在一起可能会提高效率，
    尤其是在上下没有依赖关系，编译器就更会觉得既然没有依赖关系，重排就没有影响的
##### （2）、CPU指令重排：就算编译器不发生重排，CPU也可能对指令进行重排
    CPU也可能会对指令进行重排序
##### （3）、内存的"重排序" ：线程A的修改 线程B却看不见，引出可见性问题
    
    
### 6、可见性 (JMM)
#### 1>、案例：演示什么是可见性问题
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/neicunkejianxingwenti1.jpg)
#### 2>、为什么会有可见性问题
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/weishenmehuiyoukejianxingwenti.jpg)
##### （1）、CPU有多级缓存，导致读的数据过期
###### ①、高速缓存(上层缓存 L1)的容量比主内存小，但是速度仅次于寄存器，所以在CPU和主内存之间就多了Cache层
###### ②、线程间的对于共享变量的可见性问题不是直接由多和引起的，而是由多缓存引起的。
###### ③、如果所有核心都只有用一个缓存，那么也就不存在课件性问题了，
###### ④、但是通常情况下，每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中，所以会导致有些核心读取的值是一个过期的值

#### 3>、JMM的抽象：主内存和本地内存
##### （1）、什么是主内存和本地内存
###### ①、java作为高级语言，屏蔽了这些底层细节，用JMM定义了一套读写数据的规范，虽然我们不需要关心一级缓存和二级缓存的问题，但是，JMM抽象了主内存和本地内存的概念
###### ②、这里说的本地内存并不是真的是一块给每个线程分配的内存，而是JMM的一个抽象，是对于寄存器、一级缓存、二级缓存等的抽象
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/zhuneicunhebendineicun.jpg)
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/zhuneicunhebendineicun2.jpg)

##### （2）、主内存和本地内存的关系
###### ①、JMM有以下规定：(重要)
* **所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝**
* **线程不能直接读写主内存中的变量，而是只能操作自己工作内存中的变量，然后再同步到主内存中**
* **主内存是多个线程共享的，但是线程间不共享工作内存，如果线程间需要通信，必须借助主内存中转来完成**

**所有共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，交换的过程不是实时的，所以才导致了可见性问题**

#### 4>、Happens-Before原则 （有哪些？）
##### （1）、单线程原则
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/danxianchengyuanze.jpg)

    Happens-Before的可见性保证的是如果没有发生重排序，后边的语句能看到前边执行的语句
    如果发生了重排序了，被排在后边的语句依然能够看到排在前边的语句
    Happens-Before并不影响重排序

##### （2）、锁操作(synchronized和Lock)
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/suocaozuo.jpg)

    如果一个线程对锁解锁了，另外一个线程对锁加锁了，那么这个时候加锁之后，它一定能够看到解锁之前的所有操作
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/suocaozuo2.jpg)

##### （3）、volatile变量
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/volatileguanjianzi.jpg)

    左侧是写入，右侧是读取
    只要是已经写入了，并且这个变量是被volatile修饰的，那么读取的时候就一定能够读取到最新的数据

##### （4）、线程启动
    子线程执行的所有语句都能看到主线程之前的所有语句的发生结果
    
##### （5）、线程join
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/xianchengjoin.jpg)    
    
    一旦使用了join，join后边的语句一定能看到刚才所等待的线程所执行的所有语句
    就是说保证刚才执行的线程，所有的语句都执行完，并且我都能看到
    
##### （6）、传递性
    如果hb(A,B)而且hb(B,C)，那么可以退出hb(A，C)
    
##### （7）、中断：
    一个线程被其他线程interrupt时，那么检测中断(isInterrupted) 或者抛出InterruptedException一定能看到    
    
##### （8）、构造方法：
    对象构造方法的最后一行指令 happens-before 于finalize()方法的第一行命令    
    
##### （9）、工具类的Happens-Before原则
    1、线程安全的容器get一定能看见在此之前的put等存入动作 (ConcurrentHashMap)    
    2、CountDownLatch
    3、Semaphore 从信号量中获取一个许可证，必须在此之前有一个释放，
    4、Future 可以后台执行，并且拿到执行结果的一个类
    5、线程池 
    6、CyclicBarrier
    
**近朱者赤： 给b加了volatile，不仅b被影响，也可以实现轻量级同步**
**b之前的写入(对应代码b = a)对读取b后的代码(print b)都可见，所以在writerThread里对a的赋值，一定会对readerThread里的读取可见，所以这里的a即使不加volatile，只要b读到是3，就可以有happens-before原则保证了读取到的都是3而不可能读取到1**

    
#### 5>、volatile关键字
##### （1）、volatile是什么
**volatile是一种同步机制，比synchronized或者Lock相关类更轻量，因为使用volatile并不会发生上下文切换等开销很大的行为**

**如果一个变量被修饰成volatile，那么JVM就知道了这个变量可能会被并发修改**

**但是开销小，响应的能力也小，虽然说volatile是用来同步的保证线程安全的，但是volatile做不到synchronized那样的原子保护，volatile仅在很有限的场景下才能发挥作用**

##### （2）、volatile的适用场合
###### ①、不适用：a ++ 
###### ②、适用场合1：boolean flag, 如果一个共享变量自始至终只被各个线程赋值，而没有被其他的操作，那么就可以用volatile来代替synchronized或者代替原子变量，因为赋值自身是有原子性的，而volatile又保证了可见性，所以就足以保证线程安全
###### ③、适用场合2：作为刷新之前变量的触发器
    详情看FieldVisibility类里
    
##### （3）、volatile的作用：可见性、禁止重排序
###### ①、可见性：读一个volatile变量之前，需要先使相应的本地缓存失效，这样就必须到主内存读取最新值，写一个volatile属性会立即刷入到主内存
###### ②、禁止指令重排序优化：解决单例双重锁乱序问题
  
##### （4）、volatile和synchronized的关系
###### ①、volatile在这方面可以看做是轻量级版的synchronized : 如果一个共享变量自始至终只被各个线程赋值，而没有其他的操作，那么就可以用volatile来代替synchronized或者代替原子变量， 因为赋值自身是有原子性的，而volatile又保证了可见性，所以就足以保证线程安全


##### （5）、学以致用：拥volatile修正重排序问题


##### （6）、volatile小结
* 1、volatile修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如boolean flag；或者作为触发器，实现轻量级同步。
* 2、volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间再获取锁和释放锁上，所以说它是低成本的。
* 3、volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序了
* 4、volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主存中读取。
* 5、volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其他线程后续对v的读操作
* 6、volatile可以使得long和double的赋值是原子的，后面马上会讲long和double的原子性 


#### 6>、能保证可见性的措施
##### （1）、除了volatile可以让变量保证可见性外，synchronized、Lock、并发集合、Thread.join()和Thread.start()等都可以保证可见性的
##### （2）、具体看happens-before原则的规定

#### 7>、升华：对synchronized可见性的正确理解
##### （1）、synchronized不仅保证了原子性，还保证了可见性
##### （2）、synchronized不仅让被保护的代码安全，还近朱者赤，在其他线程解锁之前的代码操作，当前获得synchronized锁的线程都可以看见，也就是保证了之前代码的可见性


### 7、原子性 (JMM)
#### 1>、什么是原子性
##### （1）、一系列的操作，要么全部执行成功，要么全部不执行，不会出现执行一半的情况，是不可分割的
##### （2）、ATM里取钱
##### （3）、i ++ 不是原子性的
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/I++bushiyuanzixing.jpg)

##### （4）、用synchronized实现原子性

#### 2>、Java中原子操作有哪些？(默认提供出来给我们用的)
##### （1）、除了long和double之外的基本类型(int、byte、Boolean、short、char、float)的赋值操作
##### （2）、所有引用reference的赋值操作，不管是32的机器还是64位的机器
##### （3）、java。concurrent.Atomic.* 包中的所有类的原子操作

#### 3>、long和double的原子性
##### （1）、问题描述：官方文档、对于 64 位的值的写入， 可以分为俩个32位的操作进行写入、读取错误、使用volatile解决
**非原子化处理double和long**

    由于Java编程语言存储器模型的目的，对非易失性long或double值的单个写入被视为两个单独的写入；每个32位半写一个，
    这可能导致线程从一次写入看到64位值的前32位，而从另一次写入看到第二次32位的情况。
    
    volatile long 和 doublevalues 的写入和读取 始终是原子的
    
    对引用的写入和读取始终是原子的， 无论他们是实现为32位还是64位。
    
    某些实现可能会发现将64位上的单个写操作long 和 double值划分为相邻的32位值上的俩个写操作很方便，
    为了效率，这种行为是特定于实现的， java虚拟机的实现可以自由的或原子的分两部分执行写入long 和 double值
    
    鼓励Java虚拟机的实现避免在可能的情况下拆分64位值，鼓励程序员将共享的64位值声明为volatile或正确同步器程序已避免可能的复杂情况
    

##### （2）、在32位上的JVM上，long和double的操作不是原子的，但是在64位的JVM上是原子的

##### （3）、实际开发中： 商用Java虚拟机中不会出现
    
#### 4>、原子操作 + 原子操作 != 原子操作
##### （1）、简单地把原子操作组合一起，并不能保证整体依然具有原子性
##### （2）、比如我去ATM机俩次取钱是俩次独立的原子操作，但是期间有可能银行卡被借给女朋友，也就是被其他线程打断并修改。
##### （3）、全同步的HashMap也不完全安全


### 8、常见面试问题
#### 1>、JMM应用实例：单例模式8中写法、单例和并发的关系(真实面试超高频考点)
##### （1）、单例模式的作用
* 1、为什么需要单例：节省内存和计算、保证结果正确，方便管理

##### （2）、单例模式的适用场景
* 1、无状态的工具类：比如日志工具类，不管是在哪里适用，我们需要的只是它帮我们记录日志信息，
    除此之外，并不需要在它的实现对象上存储任何状态，这时候我们就需要一个实例对象即可
* 2、全局信息类：比如我们在一个类上记录网站的访问此时，
    我们不希望有的访问被记录在对象A删，有的却记录在对象B上，这时候我们就让这类成为单例
    
##### （3）、单例模式的8种写法
* 1、饿汉式（静态常量）[可用]
* 2、饿汉式（静态代码块） [可用]
* 3、懒汉式（线程不安全） [不可用]
* 4、懒汉式（线程安全，同步方法）[不推荐用]
* 5、懒汉式（线程不安全， 同步代码块） [不可用]
* 6、双重检查 [推荐用]    

##### ①、优点、线程安全；延迟加载；效率较高
##### ②、为什么要double-check
      1、线程安全
      2、单check行不行
      3、性能问题
##### ③、为什么要用volatile
    1、新建对象实际上有3个步骤
        instance = new Singleton();
        1、新建一个空的对象Singleton
        2、调用构造方法生成实例
        3、然后将生成的实例的引用赋值在空对象上
* 总的新建对象的步骤就是：1先新建一个空的Singleton对象instance，
                2、然后调用Singleton对象的构造方法在堆内存中生成一个Singleton对象实例，
                3、然后在建生成的对象实例的引用赋值给空Singleton对象instance。
            

    2、重排序会带 来NPE
    3、防止重排序
    
* 7、静态内部类[推荐用]   也是懒汉模式


    由于JVM类加载的性质保证了，即便是多个线程同时去访问这个对象，它也不会建造出多个实例

* 8、枚举[推荐用]  生成实践中最佳的方式


##### （4）、不同写法对比
* 1、饿汉：简单，但是没有lazy loading
* 2、懒汉：有线程安全问题
* 3、静态内部类： 可用
* 4、双重检查：面试用
* 5、枚举：最好

##### （5）、用哪种单例的实现方案最好？
* 1、Joshua Bloch 大神在《Effective Java》中明确表达过的观点："使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法"
* 2、写法简单
* 3、线程安全有保障 
* 4、避免反序列化和反射破坏单例
    
    
**枚举类经过反编译之后会发现，枚举实际上是会被编译成一个final class， 然后继承枚举了这个父类， 并且在这个父类中他的各个属性都是通过static来定义的，所以枚举的本质经过反编译之后，就是一个静态的对象**

##### （6）、各种写法的使用场合
* 1、最好的方法是利用枚举，因为还可以防止反序列化和反射重新创建新的对象
* 2、非线程同步的方法不能使用
* 3、如果程序一开始要加载的资源太多，那么就应该使用懒加载
* 4、饿汉式如果是对象的创建需要配置文件就不适用
* 5、懒加载虽然好，但是静态内部类这种方式会引入编程复杂性

##### （7）、单例模式常见的面试问题
* 1、饿汉式的缺点？


    饿汉式确实有写法简单，线程安全的优点，
    但是饿汉式会在一上来就把资源加载，有的时候不需要这个实例，它也会加载，这个时候就造成了浪费

* 2、懒汉式的缺点？

    
    懒汉式写法相对复杂，还存在线程安全问题
    
* 3、为什么要用double-check？ 不用就不安全吗？

    
    通过代码展示
    
    
* 4、为什么双重检查模式要用volatile


    因为在构造单例，创建那个对象实例的时候，一行代码需要三个步骤，
    分别是： 1、创建一个空对象，
            2、调动构造方法
            3、将实例的地址分配给空对象的引用
    但是这三个步骤的顺序是不能保证的， 一旦 1 2 3 顺序变成了 1 3 2 ，就会出现空指针异常了 
    我们加了volatile就保证了CPU不去重排序，
    同时如果我们不加volatile，就可能出现第一个线程创建了实例，第二个线程不能及时看到。这也是可见性的问题
    
* 5、应该如何选择？用哪种单例的实现方案最好？
    
    
    应该用枚举模式来实现单例， 写法简单， 线程安全
    并且能够防止反序列化和反射破坏
    
    
#### 2>、讲一讲什么是Java内存模型(JMM)
* 1、首先要讲一下内存模型的起因，为什么会有这个，C语言没有这个会有什么问题，
* 2、JVM内存结构、Java内存模型(JMM)、Java对象模型
* 3、Java内存模型是一组规范，规范了JVM、CPU和Java代码的一系列的转换关系，帮助程序员更容易的开发，Java内存模型最终的要是原子性、可见性和重排序这三个内容
* 4、可以讲一下重排序的例子，还有重排序的好处(性能更高)
* 5、重点放在可见性， 可以讲一下关于JMM对于我们内存的抽象，抽象成主内存和本地内存(结合多级缓存画图解释)
* 6、可以说一下Happens-Before原则，再讲volatile关键字，适用场合，和synchronized的区别
* 7、说到synchronized关键字可以讲一下它不仅可以保证原子性，还可以保证可见性，还有近朱者赤的能力， 不仅能够保证它所保护的代码的线程安全，还能保证附近的代码都做到同步的效果。
* 8、讲一下原子性，Java中都有提供了哪几种原子性操作：除了long、double之外的基本类型的赋值，引用类型的赋值，还有java.concurrent.Atomic.* 包下的大部分操作都是原子的

#### 3>、volatile和synchronized的异同？
* 1、volatile实际上可以看作是轻版的synchronized，它的开销比较小，是轻量级的，适用场合也没那么广泛，只适用于被各个线程赋值，没有判断或者累加这种操作

#### 4>、什么是原子操作？ java中有哪些原子操作？ 生成对象的过程是不是原子操作？
* 关于原子操作指的是一组操作，要么全部完成，要么全部不完成，这样就是原子操作
* 1、新建一个空的Person对象
* 2、把这个对象的地址指向p
* 3、执行Person的构造函数

#### 5>、什么是内存可见性

#### 6>、64位的double和long写入的时候是原子的吗？
* 1、java并没有规定他们是原子的，写入的时候有可能就出现前32位和后32位错位的情况
* 2、但实际的商用的JVM中，都不存在这个问题， 已经被考虑清楚了
* 3、结论就是：32位上是原子的 64位不是原子的，但是实际开发的时候不需要考虑


