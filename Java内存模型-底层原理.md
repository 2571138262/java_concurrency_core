# java 并发核心知识体系精讲
核心基础 + 内存模型 + 死锁 ----- 从用法到原理
## 章节二、Java内存模型 —— 底层原理

### 1、到底什么叫"底层原理"，本章研究的内容是什么？ （绪论）
#### 1>、从Java代码到CPU指令
##### JVM实现会带来不同的"翻译"，不同的CPU平台的机器指令又不相同
##### （1）、最开始，我们编写的Java代码，是 *.java文件
##### （2）、在编译（javac命令）后，从刚才的 *.java文件会变出一个新的 *.class文件
##### （3）、JVM会执行刚才生成的字节码文件（*.class），并把字节码文件转化为机器指令
##### （4）、机器指令可以直接在CPU上执行，也就是最终的程序执行

#### 2>、重点向下研究
##### 转换过程的规范、原则

### 2、彩蛋：自顶向下的好处
#### 1>、先讲使用场景，再将用法，最后讲原理
#### 2>、直观的了解、具体而感性的认识，有助于加深理解，最后分析源码
#### 3>、连这个原理有什么作用都不知道的话，我们可定是没有兴趣的，没兴趣就意味着学不好
#### 4>、例子：《计算机网络(自顶向下方法)》、C语言学int

### 3、三兄弟： JVM内存结构 VS Java内存模型 VS Java对象模型
#### 1>、容易混淆
##### （1）、三个截然不同的概念，但是很容易弄混

#### 2>、整体方向
##### （1）、Java内存结构，和Java虚拟机的运行时区域有关。
##### （2）、Java内存模型，和Java的并发编程有关。
##### （3）、Java对象模型，和Java对象在虚拟机中的表现形式有关。

#### 3>、JVM内存结构
##### （1）、图形展示
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/JVMneicunjiegou.jpg)
##### （2）、堆区（所有线程共享）
##### （3）、java栈 虚拟机栈 VM stack（每个线程私有）
##### （4）、方法区（所有线程共享）
    已经加载的静态变量，类信息或者常量信息，还包含着永久引用   
        比如 static People people = new People(); 就是永久引用
##### （5）、本地方法区（每个线程私有）
    主要保存和本地方法相关的， native方法
##### （6）、程序计数器（每个线程私有）
    保存当前线程所执行到的字节码的行号数，也就是在进行上下文切换的时候，这些数据需要保存起来
    还包括下一条需要执行的指令、分支、循环、和异常处理，这些都依赖程序计数器的

#### 4>、Java对象模型
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/Javaduixiangmoxing.jpg)
##### （1）、Java对象自身的存储模型
##### （2）、JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。
##### （3）、当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。
    会在栈中给对象赋值，会在堆中新建实例对象


### 4、JMM是什么？（Java Memory Model） Java内存模型
#### 1>、为什么需要JMM
##### （1）、C语言不存在内存模型的概念
##### （2）、由于不存在 内存模型 的概念，所以依赖处理器，不同的处理器结构不一样
##### （3）、无法保证并发安全， 很多情况下CPU会进行乱序
##### （4）、需要一个标准，让个县城运行的结果可预期


#### 2>、是规范
##### （1）、是一种规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序
##### （2）、如果没有这样的一个JMM内存模型来规范，那么很可能经过了不同JVM的不同规则的重排序之后，导致不同的虚拟机上运行的结构不一样了，这是很大的问题

#### 3>、是工具类和关键字的原理
##### （1）、volatile、synchronized、Lock等的原理都是JMM
##### （2）、如果没有JMM，那就需要我们自己指定什么时候用内存栅栏等，那是相当麻烦的，幸好有了JMM，让我们只需要用同步工具和关键字就可以开发程序。
    工作栅栏： 简单的理解就是工作内存和主内存的拷贝和同步

#### 4>、最重要的3点内容：重排序、可见性、原子性
    JMM 最重要的三点内容：重排序、可见性、原子性

### 5、重排序 (JMM)
#### 1>、重排序的代码案例、什么是重排序
##### （1）、什么是重排序：在线程1内部的两行代码的实际执行顺序和代码在Java文件中的顺序不一致，代码指令并不是严格按照代码语句顺序执行的，他们的顺序被改变了，这还是就重排序，这里被颠倒的是y=a和b=1这两行语句

#### 2>、重排序的好处：提高处理速度
##### （1）、对比重排序前后的指令优化
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/chongpaixudehaochu.jpg)

#### 3>、重排序的3中情况：编译器优化、CPU指令重排、内存的"重排序"
##### （1）、编译器优化：包括JVM， JIT编译器等
    假设编译器发现把俩个a的操作放在一起可能会提高效率，
    尤其是在上下没有依赖关系，编译器就更会觉得既然没有依赖关系，重排就没有影响的
##### （2）、CPU指令重排：就算编译器不发生重排，CPU也可能对指令进行重排
    CPU也可能会对指令进行重排序
##### （3）、内存的"重排序" ：线程A的修改 线程B却看不见，引出可见性问题
    
    
### 6、可见性 (JMM)
#### 1>、案例：演示什么是可见性问题
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/neicunkejianxingwenti1.jpg)
#### 2>、为什么会有可见性问题
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/weishenmehuiyoukejianxingwenti.jpg)
##### （1）、CPU有多级缓存，导致读的数据过期
###### ①、高速缓存(上层缓存 L1)的容量比主内存小，但是速度仅次于寄存器，所以在CPU和主内存之间就多了Cache层
###### ②、线程间的对于共享变量的可见性问题不是直接由多和引起的，而是由多缓存引起的。
###### ③、如果所有核心都只有用一个缓存，那么也就不存在课件性问题了，
###### ④、但是通常情况下，每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中，所以会导致有些核心读取的值是一个过期的值

#### 3>、JMM的抽象：主内存和本地内存
##### （1）、什么是主内存和本地内存
###### ①、java作为高级语言，屏蔽了这些底层细节，用JMM定义了一套读写数据的规范，虽然我们不需要关心一级缓存和二级缓存的问题，但是，JMM抽象了主内存和本地内存的概念
###### ②、这里说的本地内存并不是真的是一块给每个线程分配的内存，而是JMM的一个抽象，是对于寄存器、一级缓存、二级缓存等的抽象
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/zhuneicunhebendineicun.jpg)
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/zhuneicunhebendineicun2.jpg)

##### （2）、主内存和本地内存的关系
###### ①、JMM有以下规定：(重要)
* **所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝**
* **线程不能直接读写主内存中的变量，而是只能操作自己工作内存中的变量，然后再同步到主内存中**
* **主内存是多个线程共享的，但是线程间不共享工作内存，如果线程间需要通信，必须借助主内存中转来完成**

**所有共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，交换的过程不是实时的，所以才导致了可见性问题**

#### 4>、Happens-Before原则
##### （1）、单线程原则
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/danxianchengyuanze.jpg)
    Happens-Before的可见性保证的是如果没有发生重排序，后边的语句能看到前边执行的语句
    如果发生了重排序了，被排在后边的语句依然能够看到排在前边的语句
    Happens-Before并不影响重排序

##### （2）、锁操作(synchronized和Lock)
![Image](https://github.com/2571138262/java_concurrency_core/blob/master/images-folder/suocaozuo.jpg)
    如果一个线程对锁解锁了，另外一个线程对锁加锁了，那么这个时候加锁之后，它一定能够看到解锁之前的所有操作

#### 5>、volatile关键字
#### 6>、能保证可见性的措施
#### 7>、升华：对synchronized可见性的正确理解


### 7、原子性 (JMM)

### 8、常见面试问题